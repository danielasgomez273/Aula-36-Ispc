# Aula-36-Ispc

**Integrantes:**

- Campos, Gabriel O. 
- Carballeira, Angel 
- Chávez, Laura
- Cielo, Marco 
- Covaro, Maximiliano  
- Del Hugo, Martin 
- Demarchi, Romina C.
- Durigo, Agustina 
- Gavier, Flavia  
- Gómez, Daniela S.
- Herrera, Daniel H.

## Libro 1. Scrum

## Ceremonias scrum 

### 1ra "Sprint Planning":
.    Es un reunion que se realiza al **comienzo** de cada Sprint, sirve para inspeccionar el Product Backlog y que el equipo de 
desarrollo seleccione los items del Product Backlog que va a trabajar durante el siguiente Sprint. Estos items comformoran el Sprint Backlog. En esta reunion participa el equipo Scrum al completo, el Product Owner presenta el Product Backlog y el equipo de desarrollo estima y clarifica en los items que crea necesarios. Esta reunion se divide en dos partes, en la primera se habla de QUE se tiene que hacer y en la segunda se discute el COMO hacerlo. Dado que se busca conseguir un alineamiento entre negocio y desarrollo de producto en relación a las prioridades estas reuniones saben ser largas.

### 2da "Daily Scrum":
.   Es una reunión diaria de 15 minutos en la que participa solo el equipo de desarrollo y se busca responder a lo siquiente:
    ¿Qué hice ayer para contribuir al Sprint Goal?
    ¿Qué voy a hacer hoy para contribuir al Sprint Goal?
    ¿Tengo algún impedimento que me impida entregar?

En estas reuniones se busca la inspección y adaptación a través de la auto-organización del equipo.

### 3ra "Sprint Review":
.   El Sprint Review es la reunión que ocurre al final del Sprint, generalmente el último viernes del Sprint, donde el Product Owner y el Develpment Team presentan a los Stakeholders el incremento terminado para su inspección y adaptación correspondientes. En esta reunión organizada por el Product Owner se estudia cuál es la situación y se actualiza el Product Backlog con las nuevas condiciones que puedan afectar al negocio. No se trata de una demostración, sino de una reunión de trabajo. El software ya ha sido mostrado y validado junto con el product owner previamente a esta reunión. Por un lado, se revisará el incremento terminado. Se mostrará el software funcionando en producción y los stakeholders tendrán la oportunidad de hacer cuantas preguntas estimen oportunas sobre el mismo. El software funcionando ha sido validado previamente por el product owner, que se ha encargado de trabajar con el equipo durante el Sprint para asegurarse que cumple con la Definition of Done y, efectivamente, hace que el Sprint Goal sea válido. Si no existe software funcionando, el Sprint Review carece de sentido, aunque en ciertas ocasiones y oportunidades se sigue manteniendo. El equipo de desarrollo comenta posteriormente qué ha ocurrido durante el Sprint, los impedimentos que se han encontrado, así como soluciones tomadas y actualizan a los stakeholders con la situación del equipo. Por último, el product owner actualiza -con la información de negocio recibida en esta reunión- el Product Backlog para el siguiente Sprint.

### 4ta "Sprint Retrospective":
La retrospectiva ocurre al final del Sprint, justo después del Sprint Review.El objetivo de la retrospectiva es hacer de reflexión sobre el último Sprint e identificar posibles mejoras para el próximo.Un formato común es analizar qué ha ido bien durante el Sprint, qué ha fallado y qué se puede mejorar. Este formato se puede facilitar pidiendo a los miembros del equipo Scrum que escriban notas –en post-its- para luego agruparlas y votar aquellos ítems más relevantes, dando la oportunidad a todos de hablar y expresar sus inquietudes. También se utiliza el formato de retrospectiva basado en cinco fases:
 .  Preparar el ambiente: un pequeño ejercicio para romper el hielo.
 .  Recolectar información: durante esta fase, se utilizan actividades para intentar construir una imagen de lo que ha sido el último Sprint, resultando una imagen conjunta de equipo.
 .  Generación de ideas: el equipo intenta generar ideas para identificar acciones que ayuden a mejorar el rendimiento del equipo durante el siguiente Sprint.
 .  Decidir qué hacer: de las ideas generadas, se proponen acciones que el equipo pueda implementar en el próximo Sprint.
 .  Cierre: Una pequeña actividad de cierre, normalmente unida a una evaluación de la propia retrospectiva, ayuda al equipo a decidir hacia dónde dirigirse en próximas ocasiones. Un recordatorio de la mejora continua.

### 5ta "Sprint Grooming o Refinement":
El refinamiento del Product Backlog es una práctica recomendada para asegurar que éste siempre esté preparado. Esta ceremonia sigue un patrón similar al resto y tiene una agenda fija específica en cada Sprint. Los participantes de esta reunión son todo el equipo Scrum, así como cualquier recurso adicional que considere necesario el PO y que pueda contribuir a aclarar el requerimiento. Es necesario, por tanto, que antes de la reunión todos conozcan los requerimientos o historias de usuario que van a ser tratados en la misma y sólo asistan aquellos cuya presencia sea estrictamente relevante.

Fuente https://www2.deloitte.com/es/es/pages/technology/articles/ceremonias-scrum.html

______________________________________________________________________________________________________
## Roles en Scrum 

### Product Owner
Es responsable    de definir y priorizar temas y objetivos con criterios de aceptación, el QUÉ.

### Scrum Team o Equipo
L@s estudiantes, identifican y hacen el CÓMO.

### Scrum Master o Facilitador
Será uno de los integrantes del grupo (No es un líder, ya que son equipos auto-organizados con un facilitador que les ayuda a pensar a todos juntos para obtener un resultado mejor)
______________________________________________________________________________________________________
## Artefactos Scrum 

Son aquellos elementos físicos que se producen como resultado de la aplicación de Scrum. Los tres principales artefactos o herramientas Scrum son: el Product Backlog, Sprint Backlog y el Incremento.

### Product Backlog
El Product Backlog es un inventario que contiene cualquier tipo de trabajo que haya que hacer en el producto: requerimientos, casos de uso, tareas y dependencias. Es la principal fuente de información sobre el producto en Scrum, una lista, en cualquier formato, que contiene todos los requerimientos que necesitamos implementar en el producto. Esta lista es el resultado del trabajo del Product Owner con el cliente, los distintos stakeholders, sponsors, comités, etc, y refleja el estado real del trabajo pendiente de implementar en el producto, así como el ya realizado. 

El Product Backlog debe ser gestionado en exclusiva por el Product Owner, siendo su principal función la de priorizar aquellos elementos que tienen más valor en cada etapa y detallarlos para que el equipo de desarrollo sea capaz de valorarlos y ejecutarlos.

Al comenzar a utilizar Scrum, no es necesario una lista completa y exhaustiva de todos los requerimientos. Es recomendable empezar con los dos o tres requerimientos más urgentes arriba e ir añadiendo elementos conforme vamos descubriendo más necesidades de nuestro producto.

Un Product Backlog contiene distintos elementos:
- Funcionalidades
- Bugs
- Historias de usuario
- Tareas técnicas
- Trabajo de investigación


### Sprint Backlog
Se trata de la lista de elementos en los que trabaja durante la etapa de Sprint. Estos elementos normalmente se componen de tareas técnicas más pequeñas que permiten conseguir un incremento de software terminado.

Todo el trabajo que el Development Team haya seleccionado para hacer durante el siguiente Sprint pasa al Sprint Backlog. Este artefacto es un elemento para visualizar el trabajo a realizar durante cada Sprint y está gestionado por el equipo de desarrollo. Su propósito es mantener la transparencia dentro del desarrollo, actualizándolo durante toda la iteración especialmente a través de los daily Scrums.

El Sprint Backlog permite visualizar, durante cada Sprint, aquellos elementos que aún no han empezado a desarrollarse, aquellos que sí y quiénes están trabajando en los mismos, así como aquellos que están esperando a desplegarse o están completamente terminados.

Este artefacto permite entender cuál es la evolución del trabajo durante el Sprint, así como hacer un análisis de riesgos. Dado que cada Sprint tiene una meta específica (p.e. permitir que los usuarios se registren en la app móvil) y hay elementos seleccionados del Product Backlog que tienen más o menos valor, el Sprint Backlog permite analizar hasta donde se ha cumplido el objetivo y que se podría eliminar. De esta forma, maximizamos el retorno de la inversión en desarrollo.

### Incremento
Si Scrum tuviera que ser reducido a una sola cosa, sería a entregar una pieza de software terminado en cada Sprint. Un Incremento es el resultado del Sprint, es la suma de todas las tareas, casos de uso, historias de usuario y cualquier elemento que se haya desarrollado durante el Sprint y que será puesto a disposición del usuario final en forma de software, aportando un valor de negocio al producto que se está desarrollando.

Construir software de manera ágil se basa en hacerlo de manera iterativa e incremental. Mediante las iteraciones, nos aseguramos que todo el ciclo de vida del software (planificación, diseño, desarrollo, testeo y entrega) ocurre en 4 semanas o menos. Por supuesto, no podemos construir toda la funcionalidad que queremos en solo cuatro semanas y tenemos que buscar la manera de ir entregando los componentes necesarios justo a tiempo.

### Otros artefactos
El marco de trabajo Scrum destaca los 3 elementos expuestos previamente como imprescindibles. Sin embargo, hay otros que, a pesar de no formar parte del core, son necesario para asegurar la calidad de la metodología Scrum.

**Definition of Done (DoD):** La DoD es un documento que define qué se considera hecho en un equipo Scrum. La idea es establecer una serie de criterios comunes para especificar cuando un ítem está completamente terminado y que aplique a todos los ítems que forman parte del incremento.

**Definition of Ready (DoR):** El DoR es un documento que define cuándo un requerimiento (historia de usuario o similar) se considera listo para que el equipo de desarrollo pueda entenderlo, valorarlo e incluirlo en un Sprint Planning con idea de acometerlo en un Sprint.

**Burndown Chart:** El Burndown Chart es un gráfico de trabajo pendiente a lo largo del tiempo que muestra la velocidad a la que se están completando los objetivos, requisitos, o historias de usuarios. Permite extrapolar si el equipo podrá completar el trabajo en el tiempo estimado.

### Sentencias de Git para trabajar en VSC. #15

## Clonar el repositorio con Visual Studio Code

Vamos al menú **“view”** seleccionamos **“command palette”**.  

En ese punto buscamos **“git: Clone”**. 

La herramienta nos pedirá la ruta y ahí es donde tenemos que pegar la URL del repositorio que hemos creado en el punto anterior en Github

## Hacer Push o Pull de los cambios ##

Para hacer push de los cambios o pull para copiar los datos de servidor podemos hacerlo de dos maneras:

Podemos pulsar en la parte derecha de la barra de git (icono tres puntos) y elegir la opción **push** o **pull**.

Podemos pulsar en la parte inferior sobre **sincronizar** (en este caso haríamos push y pull).

## Ver los cambios en Github ##

En GitHub dale a **“Settings / Source** y selecciona **“Master Branch”**.

**Visualiza tu web**. 

### Issue #16 Resumir de la guía de estudio el paso a paso para trabajar en Git ###

## Extraer del libro 4. GIT, correspondiente a la Guía de estudio Metodologías Agiles y Gestión de Proyectos el paso a paso para trabajar en Git (clonar repositorio, crear ramas, subir modificaciones, etc) ##

### Como clonar un repositorio ###
1)	En nuestro disco creamos una carpeta nueva, o bien abrimos una donde colocaremos nuestro proyecto. 
2)	 Dentro de la carpeta hacer click derecho y seleccionar **GIT BASH HERE** (que abre la consola de git)
3)	Nos dirigimos a nuestro repositorio en GitHub en la pestaña de **“Code”** o **“Código”**, luego verificamos que estemos parados sobre la **“rama”** o **“branch”**, **“main”** o **“principal”**, y presionamos sobre el botón verde que dice **“Code”** o **“Código”**. Luego copiamos la dirección marcada que es por protocolo **HTTPS**.
4)	Dentro de la consola tipear git clone y pegar la direccion copiada en el punto anterior, y damos enter.
5)	 Veremos que dentro de la carpeta del punto 1, se nos creo otra carpeta con el nombre del proyecto.

### Como crear una rama ###
1)	Volvemos a la consola y tipeamos **cd + “nombre_del_proyecto”** para posicionarnos dentro del mismo (o desde el explorador, abrimos la carpeta "nombre_del_proyecto", damos click derecho y seleccionamos **GIT BASH HERE**.)
2)	Tipeamos el comando **git branch "nombre_de_la_rama"** (el nombre que quieran, en mi caso usé desarrolladorMaxi), y damos Enter. Veremos en la consola que seguimos en la rama main o master.
3)	Para entrar a nuestra rama: escribimos el comando **git checkout "nombre_de_la_rama"** y damos enter.
Luego de haber realizado estos pasos ya podemos empezar a trabajar sobre nuestro “espacio de trabajo” o “branch” o “rama” como más les guste llamarlo.

### Como subir codigo a Github mediante Git ###
1)	Abrir la consola de git en la carpeta en la cual se clonaron el proyecto, donde veremos que se encuentran las carpetas .git y .github.
2)	Dentro de la consola tipeamos el comando **git status** para poder ver los cambios que tenemos en nuestro espacio o rama de trabajo. Nos mostrará en rojo los archivos que hayamos modificado.
3)	Para agregar estos archivos al commit para luego subirlos debemos ingresar el comando **git add + “nombre_de_archivo”** (si solo queremos subir los cambios de un archivo especifico), o el comando **git add .** (si queremos subir todos los cambios realizados.)
4)	Una vez realizado el paso anterior, tipeamos el comando **git status** y veremos que el/los archivo/s subidos se encuentran en color verde.
5)	Luego debemos ingresar el comando **git commit –m “aquí agregamos un mensaje descriptivo de lo que estamos por subir al repositorio”** (para identificar los cambios a subir)
6)	Ahora vamos a ingresar el comando **git pull origin main**, para bajarnos o tener al día todos los cambios que estén en la rama principal del repositorio remoto (para no perder ningún cambio que hayan realizado los demás participantes del grupo en el repositorio)
7)	Luego de habernos bajado todos los cambios y de que se hayan “fusionado” o “mergeado” automáticamente se deben de subir nuestros cambios locales al repositorio remoto con el comando **git push** ó para más seguridad especificarle desde donde se quieren subir los cambios con el comando **git push origin + “nombre_de_la_rama”**.
Luego de realizados estos pasos nos dirigimos a GitHub para realizar la correcta fusión desde “nuestra rama” ó “espacio de trabajo” hacia la rama “principal” ó “main”.
1)	En GitHub nos encontraremos con un cartel que nos indica el nombre de nuestra rama (en la que estuvimos trabajando), avisándonos de que se subió código recientemente, brindándonos un botón de color verde que nos dice **“Compare & pull request”** ó “Comparar y solicitar extracción”.
2)	Al presionar este botón **“Compare & pull request”** ó “Comparar y solicitar extracción” nos muestra las opciones de la siguiente pantalla, donde nos deja proporcionarle un título y una descripción a la fusión de los cambios. Luego de realizadas estas acciones presionamos en el botón **“Create pull request”** ó “Crear solicitud de Extracción”.
3)	Luego redirecciona a la siguiente pantalla proporcionando la información de la fusión de los cambios y que la rama no cuenta con conflictos con la rama Base, y presionamos el botón **“Merge pull request”** o “Combinar solicitud de extracción”.
4)	Por último, presionamos el botón **“Confirm merge”** o “Confirmar fusión”. 

### Acerca del Control de Versiones ###
Un control de versiones es un sistema que registra los cambios realizados en un archivo o conjunto de archivos a lo largo del tiempo, de modo que puedas recuperar versiones específicas más adelante. Permite regresar a versiones anteriores de tus archivos, regresar a una versión anterior del proyecto completo, comparar cambios a lo largo del tiempo, ver quién modificó por última vez algo que pueda estar causando problemas, ver quién introdujo un problema y cuándo, y mucho más. Usar un VCS también significa generalmente que si arruinas o pierdes archivos, será posible recuperarlos fácilmente. Adicionalmente, obtendrás todos estos beneficios a un costo muy bajo.

### Sistemas de Control de Versiones Locales ###
Se trata de copiar los archivos a otro directorio. Es muy sencillo, pero también es tremendamente propenso a errores. Es fácil olvidar en qué directorio te encuentras y guardar accidentalmente en el archivo equivocado o sobrescribir archivos que no querías. Para afrontar este problema los programadores desarrollaron hace tiempo VCS locales que contenían una simple base de datos, en la que se llevaba el registro de todos los cambios realizados a los archivos.
Sistemas de Control de Versiones Centralizados
Fueron desarrollados para poder colaborar con desarrolladores en otros sistemas. Tienen un único servidor que contiene todos los archivos versionados y varios clientes que descargan los archivos desde ese lugar central. Este ha sido el estándar para el control de versiones por muchos años. Todas las personas saben hasta cierto punto en que están trabajando los otros colaboradores del proyecto. Los administradores tienen control detallado sobre qué puede hacer cada usuario, y es mucho más fácil administrar un CVCS que tener que lidiar con bases de datos locales en cada cliente. Su mayor desventaja la representa el servidor centralizado. Si ese servidor se cae, en ese momento nadie podrá colaborar o guardar cambios en archivos en los que hayan estado trabajando. Si el disco duro en el que se encuentra la base de datos central se corrompe, y no se han realizado copias de seguridad adecuadamente, se perderá toda la información del proyecto, con excepción de las copias instantáneas que las personas tengan en sus máquinas locales. Los VCS locales sufren de este mismo problema: Cuando tienes toda la historia del proyecto en un mismo lugar, te arriesgas a perderlo todo.

### Sistemas de Control de Versiones Distribuidos ###
En un DVCS (como Git, Mercurial, Bazaar o Darcs), los clientes no solo descargan la última copia instantánea de los archivos, sino que se replica completamente el repositorio. De esta manera, si un servidor deja de funcionar y estos sistemas estaban colaborando a travésde él, cualquiera de los repositorios disponibles en los clientes puede ser copiado al servidor con el fin de restaurarlo. Cada clon es realmente una copia completa de todos los datos.

### Una breve historia de Git ###
El kernel de Linux es un proyecto de software de código abierto con un alcance bastante amplio. Durante la mayor parte de su mantenimiento (1991-2002), los cambios en el software se realizaban a través de parches y archivos. En el 2002, el proyecto del kernel de Linux comenzó a usar un DVCS propietario llamado BitKeeper.
En el 2005, la relación entre la comunidad que desarrollaba el kernel de Linux y la compañía que desarrollaba BitKeeper se vino abajo y la herramienta dejó de ser ofrecida de manera gratuita. Esto impulsó a la comunidad de desarrollo de Linux (y en particular a Linus Torvalds, el creador de Linux) a desarrollar su propia herramienta basada en algunas de las lecciones que aprendieron mientras usaban BitKeeper.
Algunos de los objetivos del nuevo sistema fueron los siguientes:
● Velocidad
● Diseño sencillo
● Gran soporte para desarrollo no lineal (miles de ramas paralelas)
● Completamente distribuido
● Capaz de manejar grandes proyectos (como el kernel de Linux) eficientemente
(velocidad y tamaño de los datos)
Desde su nacimiento en el 2005, Git ha evolucionado y madurado para ser fácil de usar y conservar sus características iniciales. Es tremendamente rápido, muy eficiente con grandes proyectos y tiene un increíble sistema de ramificación (branching) para desarrollo no lineal.
### Copias instantáneas ###
Git maneja sus datos como un conjunto de copias instantáneas de un sistema de archivos miniatura. Cada vez que confirmas un cambio, o guardas el estado de tu proyecto en Git, él básicamente toma una foto del aspecto de todos tus archivos en ese momento y guarda una referencia a esa copia instantánea. Si los archivos no se han modificado Git almacena solo un enlace al archivo anterior idéntico que ya tiene almacenado.
### Casi todas las operaciones son locales ###
Por lo general no se necesita información de ningún otro computador de tu red.  Debido a que tienes toda la historia del proyecto ahí mismo, en tu disco local, la mayoría de las operaciones parecen prácticamente inmediatas. Por ejemplo, para navegar por la historia del proyecto, Git no necesita conectarse al servidor para obtener la historia y mostrarla -simplemente la lee directamente de tu base de datos local. Si quieres ver los cambios introducidos en un archivo entre la versión actual y la de hace un mes, Git puede buscar el archivo de hace un mes y hacer un cálculo de diferencias localmente, en lugar de tener que pedirle a un servidor remoto que lo haga, u obtener una versión antigua desde la red y hacerlo de manera local. En muchos otros sistemas, esto es imposible o muy engorroso.
### Git tiene integridad ###
Todo en Git es verificado mediante una suma de comprobación (checksum en inglés) antes de ser almacenado, y es identificado a partir de ese momento mediante dicha suma. Esto significa que es imposible cambiar los contenidos de cualquier archivo o directorio sin que Git lo sepa. El mecanismo que usa Git para generar esta suma de comprobación se conoce como hash SHA-1. Se trata de una cadena de 40 caracteres hexadecimales (0-9 y a-f), y se calcula con base en los contenidos del archivo o estructura del directorio en Git. Un hash SHA-1 se ve de la siguiente forma: **24b9da6552252987aa493b52f8696cd6d3b00373**. Verás estos valores hash por todos lados en Git, porque son usados con mucha frecuencia. Git guarda todo por el valor hash de sus contenidos.
### Git generalmente solo añade información ###
Cuando realizas acciones en Git, casi todas ellas sólo añaden información a la base de
datos de Git. Después de confirmar una copia instantánea en Git es muy difícil perderla, especialmente si envías tu base de datos a otro repositorio con regularidad.
### Los Tres Estados ###
Git tiene tres estados principales en los que se pueden encontrar tus archivos: confirmado (committed), modificado (modified), y preparado (staged). 
**Confirmado:** significa que los datos están almacenados de manera segura en tu base de datos local. 
**Modificado:** significa que has modificado el archivo pero todavía no lo has confirmado a tu base de datos. 
**Preparado:** significa que has marcado un archivo modificado en su versión actual para que vaya en tu próxima confirmación. 
Esto nos lleva a las tres secciones principales de un proyecto de Git: 
**El directorio de Git (Git directory), 
el directorio de trabajo (working directory), 
y el área de preparación (staging area).**
El directorio de Git es donde se almacenan los metadatos y la base de datos de objetos para tu proyecto. Es la parte más importante de Git, y es lo que se copia cuando se clona un repositorio desde otra computadora. El directorio de trabajo es una copia de una versión del proyecto. Estos archivos se sacan de la base de datos comprimida en el directorio de Git, y se colocan en disco para que los puedas usar o modificar. El área de preparación es un archivo, generalmente contenido en tu directorio de Git, que almacena información acerca de lo que va a ir en tu próxima confirmación. A veces se le denomina índice (“index”), pero se está convirtiendo en estándar el referirse a ella como el área de preparación.
El flujo de trabajo básico en Git es algo así:
● Modificas una serie de archivos en tu directorio de trabajo.
● Preparas los archivos, añadiéndolos a tu área de preparación.
● Confirmas los cambios, lo que toma los archivos tal y como están en el área de preparación y almacena esa copia instantánea de manera permanente en tu directorio de Git.
Si una versión concreta de un archivo está en el directorio de Git, se considera confirmada (committed). Si ha sufrido cambios desde que se obtuvo del repositorio, pero ha sido añadida al área de preparación, está preparada (staged). Y si ha sufrido cambios desde que se obtuvo del repositorio, pero no se ha preparado, está modificada (modified).

### Instalación de Git ###
Antes de comenzar a utilizar Git, tienes que instalarlo en tu computadora. Incluso si ya está instalado, este es posiblemente un buen momento para actualizarlo a su última versión. Puedes instalarlo como un paquete, a partir de un archivo instalador o bajando el código fuente y compilándolo tú mismo.
**Instalación en Linux**
$ apt-get install git

**Instalación en Windows**
https://git-scm.com/downloads
### Configurando Git por primera vez ###
Es necesario hacer estas cosas solamente una vez en tu computadora, y se mantendrán entre actualizaciones. También puedes cambiarlas en cualquier momento volviendo a ejecutar los comandos correspondientes. Git trae una herramienta llamada git config, que te permite obtener y establecer variables de configuración que controlan el aspecto y funcionamiento de Git. Estas variables pueden almacenarse en tres sitios distintos:
1. Archivo /etc/gitconfig: Contiene valores para todos los usuarios del sistema y todos sus repositorios. Si pasas la opción --system a git config, lee y escribe específicamente en este archivo.
2. Archivo ~/.gitconfig o ~/.config/git/config: Este archivo es específico de tu usuario. Puedes hacer que Git lea y escriba específicamente en este archivo pasando la opción --global.
3. Archivo config en el directorio de Git (es decir, .git/config) del repositorio que estés utilizando actualmente: Este archivo es específico del repositorio actual. 
Cada nivel sobrescribe los valores del nivel anterior, por lo que los valores de .git/config tienen preferencia sobre los de /etc/gitconfig. En sistemas Windows, Git busca el archivo .gitconfig en el directorio HOME -para mucha gente será C:\Users\$USER. También busca el archivo /etc/gitconfig, aunque esta ruta es relativa a la raíz MSys, que es donde decidiste instalar Git en tu sistema Windows cuando ejecutaste el instalador.
### Tu Identidad ### 
Lo primero que deberás hacer cuando instales Git es establecer tu nombre de usuario y dirección de correo electrónico. Esto es importante porque los "commits" de Git usan esta información, y es introducida de manera inmutable en los commits que envías:

**$ git config --global user.name "John Doe"**

**$ git config --global user.email johndoe@example.com**

De nuevo, sólo necesitas hacer esto una vez si especificas la opción --global, ya que Git siempre usará esta información para todo lo que hagas en ese sistema. Si quieres sobrescribir esta información con otro nombre o dirección de correo para proyectos específicos, puedes ejecutar el comando sin la opción --global cuando estés en ese proyecto.
Muchas de las herramientas de interfaz gráfica te ayudarán a hacer esto la primera vez que las uses.
### Tu Editor ### 
Ahora que tu identidad está configurada, puedes elegir el editor de texto por defecto que se utilizará cuando Git necesite que introduzcas un mensaje. Si no indicas nada, Git usará el editor por defecto de tu sistema, que generalmente es Vim. Si quieres usar otro editor de texto como Emacs, puedes hacer lo siguiente:

**$ git config --global core.editor emacs**

### Comprobando tu Configuración ### 
Si quieres comprobar tu configuración, puedes usar el comando git config --list para mostrar todas las propiedades que Git ha configurado.
Puede que veas claves repetidas, porque Git lee la misma clave de distintos archivos (/etc/gitconfig y ~/.gitconfig, por ejemplo). En estos casos, Git usa el último valor para cada clave única que ve.
También puedes comprobar el valor que Git utilizará para una clave específica ejecutando git config <key
### ¿Cómo obtener ayuda? ### 

**$ git help <verb>**

**$ git <verb> --help**

**$ man git-<verb>**

Por ejemplo, puedes ver la página del manual para el comando config ejecutando

**$ git help config**

Estos comandos son muy útiles porque puedes acceder a ellos desde cualquier sitio, incluso sin conexión.
Inicializando un repositorio en un directorio existente
Si estás comenzando a seguir un proyecto existente en Git, debes ir al directorio del proyecto y usar el siguiente comando:

**$ git init**

Esto crea un subdirectorio nuevo llamado .git, el cual contiene todos los archivos necesarios del repositorio – un esqueleto de un repositorio de Git. Todavía no hay nada en tu proyecto que esté bajo seguimiento. Puedes revisar Los entresijos internos de Git para obtener más información acerca de los archivos presentes en el directorio .git que acaba de ser creado. Si deseas comenzar a controlar versiones de archivos existentes (a diferencia de un directorio vacío), probablemente deberías comenzar el seguimiento de esos archivos y hacer una confirmación inicial. Puedes conseguirlo con unos pocos comandos git add para especificar qué archivos quieres controlar, seguidos de un git commit para confirmar los cambios:

$ git add *.c

$ git add LICENSE

$ git commit -m 'initial project version'

En este momento, tienes un repositorio de Git con archivos bajo seguimiento y una confirmación inicial.
### Guardando cambios en el Repositorio ### 
El siguiente paso es realizar algunos cambios y confirmar instantáneas de esos cambios en el repositorio cada vez que el proyecto alcance un estado que quieras conservar. Recuerda que cada archivo de tu repositorio puede tener dos estados: rastreados y sin rastrear. Los archivos rastreados (tracked files en inglés) son todos aquellos archivos que estaban en la última instantánea del proyecto; pueden ser archivos sin modificar, modificados o preparados. Los archivos sin rastrear son todos los demás – cualquier otro archivo en tu directorio de trabajo que no estaba en tu última instantánea y que no está en el área de preparación (staging area). Cuando clonas por primera vez un repositorio, todos tus archivos estarán rastreados y sin modificar pues acabas de sacarlos y aún no han sido editados.
### Revisando el Estado de tus Archivos ### 
La herramienta principal para determinar qué archivos están en qué estado es el comando git status. Si ejecutas este comando inmediatamente después de clonar un repositorio, deberías ver algo como esto:

**$ git status
On branch master
nothing to commit, working directory clean**

Esto significa que no hay archivos rastreados y modificados. Además, Git no encuentra archivos sin rastrear, de lo contrario aparecerán listados aquí. Finalmente, el comando te indica en cuál rama estás y te informa que no ha variado con respecto a la misma rama en el servidor. Por ahora, la rama siempre será “master”, que es la rama por defecto; no le prestaremos atención de momento.
Sin rastrear significa que Git ve archivos que no tenías en el commit anterior. Git no los incluirá en tu próximo commit a menos que se lo indiques explícitamente. Se comporta así para evitar incluir accidentalmente archivos binarios o cualquier otro archivo que no quieras incluir
### Rastrear Archivos Nuevos ###
Debes usar el comando git add. Para comenzar a rastrear un archivo. Ahora si vuelves a ver el estado del proyecto, verás que el archivo está siendo rastreado y está preparado para ser confirmado.
Anteriormente cuando ejecutaste git init, ejecutaste luego git add (files) - lo cual inició el rastreo de archivos en tu directorio. El comando git add puede recibir tanto una ruta de archivo como de un directorio; si es de un directorio, el comando añade recursivamente los archivos que están dentro de él.
### Preparar Archivos Modificados ### 
Si cambias el archivo rastreado llamado “CONTRIBUTING.md” y luego ejecutas el comando git status, verás algo parecido a esto:

$ git status
On branch master
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
new file: README
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working
directory)
modified: CONTRIBUTING.md

El archivo “CONTRIBUTING.md” aparece en una sección llamada “Changes not staged for commit” (“Cambios no preparado para confirmar” en inglés) - lo que significa que existe un archivo rastreado que ha sido modificado en el directorio de trabajo pero que aún no está preparado. Para prepararlo, ejecutas el comando git add. git add es un comando que cumple varios propósitos - lo usas para comenzar a rastrear archivos nuevos, preparar archivos, y hacer otras cosas como marcar resuelto archivos en conflicto por combinación. Es más útil que lo veas como un comando para “añadir este contenido a la próxima confirmación” más que para “añadir este archivo al proyecto”.
Ejecutemos git add para preparar el archivo “CONTRIBUTING.md” y luego ejecutemos git status. Ambos archivos están preparados y formarán parte de tu próxima confirmación. En este momento, supongamos que recuerdas que debes hacer un pequeño cambio en CONTRIBUTING.md antes de confirmarlo. Abres de nuevo el archivo, lo cambias y ahora estás listo para confirmar. Sin embargo, ejecutemos git status una vez más: Ahora CONTRIBUTING.md aparece como preparado y como no preparado. ¿Cómo es posible? Resulta que Git prepara un archivo de acuerdo al estado que tenía cuando ejecutas el comando git add. Si confirmas ahora, se confirmará la versión de CONTRIBUTING.md que tenías la última vez que ejecutaste git add y no la versión que ves ahora en tu directorio de trabajo al ejecutar git status. Si modificas un archivo luego de ejecutar git add, deberás ejecutar git add de nuevo para preparar la última versión del archivo.
###  Ignorar Archivos ### 
A veces, tendrás algún tipo de archivo que no quieres que Git añada automáticamente o más aún, que ni siquiera quieras que aparezca como no rastreado. Este suele ser el caso de archivos generados automáticamente como trazas o archivos creados por tu sistema de compilación. En estos casos, puedes crear un archivo llamado .gitignore que liste patrones a considerar. Este es un ejemplo de un archivo .gitignore:

$ cat .gitignore
*.[oa]
*~

La primera línea le indica a Git que ignore cualquier archivo que termine en “.o” o “.a” - archivos de objeto o librerías que pueden ser producto de compilar tu código. La segunda línea le indica a Git que ignore todos los archivos que terminen con una tilde (~), la cual es usada por varios editores de texto como Emacs para marcar archivos temporales. También puedes incluir cosas como trazas, temporales, o pid directamente; documentación generada automáticamente; etc. Crear un archivo .gitignore antes de comenzar a trabajar es generalmente una buena idea, pues así evitas confirmar accidentalmente archivos que en realidad no quieres incluir en tu repositorio Git.

Las reglas sobre los patrones que puedes incluir en el archivo .gitignore son las siguientes:
● Ignorar las líneas en blanco y aquellas que comienzan con #.
● Aceptar patrones glob estándar.
● Los patrones pueden terminar en barra (/) para especificar un directorio.
● Los patrones pueden negarse si se añade al principio el signo de exclamación
(!).
Los patrones glob son una especie de expresión regular simplificada usada por los terminales. Un asterisco (*) corresponde a cero o más caracteres; [abc] corresponde a cualquier caracter dentro de los corchetes (en este caso a, b o c); el signo de interrogación (?) corresponde a un caracter cualquiera; y los corchetes sobre caracteres separados por un guión ([0-9]) corresponde a cualquier caracter entre ellos (en este caso del 0 al 9). También puedes usar dos asteriscos para indicar directorios anidados; a/**/z coincide con a/z, a/b/z, a/b/c/z, etc.
### Ver los Cambios Preparados y No Preparados ### 
Si el comando git status es muy impreciso para ti - quieres ver exactamente qué ha cambiado, no solo cuáles archivos lo han hecho - puedes usar el comando git diff, que te muestra las líneas exactas que fueron añadidas y eliminadas, es decir, el parche. 
Es importante resaltar que al llamar a git diff sin parámetros no verás los cambios desde tu última confirmación - solo verás los cambios que aún no están preparados. Esto puede ser confuso porque si preparas todos tus cambios, git diff no te devolverá ninguna salida.
### Confirmar tus Cambios ### 
Ahora que tu área de preparación está como quieres, puedes confirmar tus cambios. Recuerda que cualquier cosa que no esté preparada - cualquier archivo que hayas creado o modificado y que no hayas agregado con git add desde su edición - no será confirmado. Se mantendrán como archivos modificados en tu disco. En este caso, digamos que la última vez que ejecutaste git status verificaste que todo estaba preparado y que estás listo para confirmar tus cambios. La forma más sencilla de confirmar es escribiendo git commit:

**$ git commit**

Al hacerlo, arrancará el editor de tu preferencia. (El editor se establece a través de la variable de ambiente $EDITOR de tu terminal - usualmente es vim o emacs, aunque puedes configurarlo con el editor que quieras usando el comando git config –global core.editor
### Saltar el Área de Preparación ### 
Si quieres saltarte el área de preparación, Git te ofrece un atajo sencillo. Añadiendo la opción -a al comando git commit harás que Git prepare automáticamente todos los archivos rastreados antes de confirmarlos, ahorrandote el paso de git add.
### Eliminar Archivos ### 
Para eliminar archivos de Git, debes eliminarlos de tus archivos rastreados (o mejor dicho, eliminarlos del área de preparación) y luego confirmar. Para ello existe el comando git rm, que además elimina el archivo de tu directorio de trabajo de manera que no aparezca la próxima vez como un archivo no rastreado. Si simplemente eliminas el archivo de tu directorio de trabajo, aparecerá en la sección “Changes not staged for commit” (esto es, sin preparar) en la salida de git status
Con la próxima confirmación, el archivo habrá desaparecido y no volverá a ser rastreado. Si modificaste el archivo y ya lo habías añadido al índice, tendrás que forzar su eliminación con la opción -f. Esta propiedad existe por seguridad, para prevenir que elimines accidentalmente datos que aún no han sido guardados como una instantánea y que por lo tanto no podrás recuperar luego con Git. Otra cosa que puedas querer hacer es mantener el archivo en tu directorio de trabajo pero eliminarlo del área de preparación. En otras palabras, quisieras mantener el archivo en tu disco duro pero sin que Git lo siga rastreando. Esto puede ser particularmente útil si olvidaste añadir algo en tu archivo .gitignore y lo preparaste accidentalmente, algo como un gran archivo de trazas a un montón de archivos compilados .a. Para hacerlo, utiliza la opción –cached.
Al comando git rm puedes pasarle archivos, directorios y patrones glob. Lo que significa que puedes hacer cosas como

**$ git rm log/\*.log**

Fíjate en la barra invertida (\) antes del asterisco *. Esto es necesario porque Git hace su propia expansión de nombres de archivo, aparte de la expansión hecha por tu terminal. Este comando elimina todos los archivo que tengan la extensión .log dentro del directorio log/. O también puedes hacer algo como:

**$ git rm \*~**

Este comando elimina todos los archivos que acaben con ~.
### Cambiar el Nombre de los Archivos ### 
Si quieres renombrar un archivo en Git, puedes ejecutar algo como

**$ git mv file_from file_to**

### Ver el Historial de Confirmaciones ### 
La herramienta más básica y potente para hacer esto es el comando git log. Estos ejemplos usan un proyecto muy sencillo llamado “simplegit”. Para clonar el proyecto, ejecuta:

**git clone https://github.com/schacon/simplegit-progit**

Por defecto, si no pasas ningún parámetro, git log lista las confirmaciones hechas sobre ese repositorio en orden cronológico inverso. Es decir, las confirmaciones más recientes se muestran al principio. Como puedes ver, este comando lista cada confirmación con su suma de comprobación SHA-1, el nombre y dirección de correo del autor, la fecha y el mensaje de confirmación. El comando git log proporciona gran cantidad de opciones para mostrarte exactamente lo que buscas. Aquí veremos algunas de las más usadas. Una de las opciones más útiles es -p, que muestra las diferencias introducidas en cada confirmación. También puedes usar la opción -2, que hace que se muestren únicamente las dos últimas entradas del historial.
Esta opción muestra la misma información, pero añadiendo tras cada entrada las diferencias que le corresponden. Esto resulta muy útil para revisiones de código, o para visualizar rápidamente lo que ha pasado en las confirmaciones enviadas por un colaborador. También puedes usar con git log una serie de opciones de resumen. Por ejemplo, si quieres ver algunas estadísticas de cada confirmación, puedes usar la opción –stat.
La opción **--stat** imprime tras cada confirmación una lista de archivos modificados, indicando cuántos han sido modificados y cuántas líneas han sido añadidas y eliminadas para cada uno de ellos, y un resumen de toda esta información. Otra opción realmente útil es **--pretty**, que modifica el formato de la salida. Tienes unos cuantos estilos disponibles. La opción **oneline** imprime cada confirmación en una única línea, lo que puede resultar útil si estás analizando gran cantidad de confirmaciones. Otras opciones son **short, full y fuller**, que muestran la salida en un formato parecido, pero añadiendo menos o más información, respectivamente.
La opción más interesante es **format**, que te permite especificar tu propio formato. Esto resulta especialmente útil si estás generando una salida para que sea analizada por otro programa —como especificas el formato explícitamente, sabes que no cambiará en futuras actualizaciones de Git—.
Puede que te estés preguntando la diferencia entre autor **(author)** y confirmador **(committer)**. El autor es la persona que escribió originalmente el trabajo, mientras que el confirmador es quien lo aplicó. Por tanto, si mandas un parche a un proyecto, y uno de sus miembros lo aplica, ambos recibiréis reconocimiento —tú como autor, y el miembro del proyecto como confirmador—. Las opciones oneline y format son especialmente útiles combinadas con otra opción llamada **--graph**. Ésta añade un pequeño gráfico ASCII mostrando tu historial de ramificaciones y uniones.
### Deshacer Cosas ### 
En cualquier momento puede que quieras deshacer algo. Ten cuidado, a veces no es posible recuperar algo luego que lo has deshecho. Esta es una de las pocas áreas en las que Git puede perder parte de tu trabajo si cometes un error. Una de las acciones más comunes a deshacer es cuando confirmas un cambio antes de tiempo y olvidas agregar algún archivo, o te equivocas en el mensaje de confirmación. Si quieres rehacer la confirmación, puedes reconfirmar con la opción **–amend**.
Este comando utiliza tu área de preparación para la confirmación. Si no has hecho cambios desde tu última confirmación (por ejemplo, ejecutas este comando justo después de tu confirmación anterior), entonces la instantánea lucirá exactamente igual y lo único que cambiarás será el mensaje de confirmación. Se lanzará el mismo editor de confirmación, pero verás que ya incluye el mensaje de tu confirmación anterior. Puedes editar el mensaje como siempre y se sobreescribirá tu confirmación anterior. 
Al final terminarás con una sola confirmación - la segunda confirmación reemplaza el resultado de la primera.
### Deshacer un Archivo Preparado ### 
Las siguientes dos secciones muestran cómo lidiar con los cambios de tu área de preparación y tú directorio de trabajo. Afortunadamente, el comando que usas para determinar el estado de esas dos áreas también te recuerda cómo deshacer los cambios en ellas. Por ejemplo, supongamos que has cambiado dos archivos y que quieres confirmarlos como dos cambios separados, pero accidentalmente has escrito git add * y has preparado ambos. ¿Cómo puedes sacar del área de preparación uno de ellos? El comando git status te recuerda cómo:

$ git add .
$ git status
On branch master
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
renamed: README.md -> README
modified: CONTRIBUTING.md

Justo debajo del texto “Changes to be committed” (“Cambios a ser confirmados”, en inglés), verás que dice que uses git reset HEAD <file>... para deshacer la preparación. Por lo tanto, usemos el consejo para deshacer la preparación del archivo CONTRIBUTING.md:

$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
renamed: README.md -> README
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working
directory)
modified: CONTRIBUTING.md

El comando es un poco raro, pero funciona. El archivo CONTRIBUTING.md está modificado y, nuevamente, no preparado.
### Deshacer un Archivo Modificado ### 
Afortunadamente, git status también te dice cómo hacerlo. En la salida anterior, el área no preparada lucía así:

Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working
directory)
modified: CONTRIBUTING.md

Allí se te indica explícitamente cómo descartar los cambios que has hecho. Hagamos lo que nos dice:

$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
renamed: README.md -> README

Ahora puedes ver que los cambios se han revertido.
### Trabajar con Remotos ### 
Para poder colaborar en cualquier proyecto Git, necesitas saber cómo gestionar repositorios remotos. Los repositorios remotos son versiones de tu proyecto que están hospedadas en Internet o en cualquier otra red. Puedes tener varios de ellos, y en cada uno tendrás generalmente permisos de solo lectura o de lectura y escritura. Colaborar con otras personas implica gestionar estos repositorios remotos enviando y trayendo datos de ellos cada vez que necesites compartir tu trabajo. Gestionar repositorios remotos incluye saber cómo añadir un repositorio remoto, eliminar los remotos que ya no son válidos, gestionar varias ramas remotas, definir si deben rastrearse o no y más.
### Ver Tus Remotos ### 
Para ver los remotos que tienes configurados, debes ejecutar el comando git remote. Mostrará los nombres de cada uno de los remotos que tienes especificados. Si has clonado tu repositorio, deberías ver al menos origin (origen, en inglés) - este es el nombre que por defecto Git le da al servidor del que has clonado:
También puedes pasar la opción -v, la cual muestra las URLs que Git ha asociado al nombre y que serán usadas al leer y escribir en ese remoto. Si tienes más de un remoto, el comando los listará todos. 
### Añadir Repositorios Remotos ### 
Para añadir un remoto nuevo y asociarlo a un nombre que puedas referenciar fácilmente, ejecuta git remote add [nombre] [url].
A partir de ahora puedes usar el nombre pb en la línea de comandos en lugar de la URL entera. 
### Traer y Combinar Remotos ### 
Como hemos visto hasta ahora, para obtener datos de tus proyectos remotos puedes ejecutar:

**$ git fetch [remote-name]**

El comando irá al proyecto remoto y se traerá todos los datos que aún no tienes de dicho remoto. Luego de hacer esto, tendrás referencias a todas las ramas del remoto, las cuales puedes combinar e inspeccionar cuando quieras. Si clonas un repositorio, el comando de clonar automáticamente añade ese repositorio remoto con el nombre “origin”. Por lo tanto, git fetch origin se trae todo el trabajo nuevo que ha sido enviado a ese servidor desde que lo clonaste (o desde la última vez que trajiste datos). Es importante destacar que el comando git fetch solo trae datos a tu repositorio local - ni lo combina automáticamente con tu trabajo ni modifica el trabajo que llevas hecho. La combinación con tu trabajo debes hacerla manualmente cuando estés listo. Si has configurado una rama para que rastree una rama remota (más información en la siguiente sección y en Ramificaciones en Git), puedes usar el comando git pull para traer y combinar automáticamente la rama remota con tu rama actual. Es posible que este sea un flujo de trabajo mucho más cómodo y fácil para ti; y por defecto, el comando git clone le indica automáticamente a tu rama maestra local que rastree la rama maestra remota (o como se llame la rama por defecto) del servidor del que has clonado. Generalmente, al ejecutar git pull traerás datos del servidor del que clonaste originalmente y se intentará combinar automáticamente la información con el código en el que estás trabajando.
### Enviar a Tus Remotos ### 
Cuando tienes un proyecto que quieres compartir, debes enviarlo a un servidor. El comando para hacerlo es simple: **git push [nombre-remoto] [nombre-rama]**. Si quieres enviar tu rama master a tu servidor origin (recuerda, clonar un repositorio establece esos nombres automáticamente), entonces puedes ejecutar el siguiente comando y se enviarán todos los commits que hayas hecho al servidor:

**$ git push origin master**

Este comando solo funciona si clonaste de un servidor sobre el que tienes permisos de escritura y si nadie más ha enviado datos por el medio. Si alguien más clona el mismo repositorio que tú y envía información antes que tú, tu envío será rechazado. Tendrás que traerte su trabajo y combinarlo con el tuyo antes de que puedas enviar datos al servidor.
Inspeccionar un Remoto
Si quieres ver más información acerca de un remoto en particular, puedes ejecutar el comando **git remote show [nombre-remoto]**. 
El comando lista la URL del repositorio remoto y la información del rastreo de ramas. El comando te indica claramente que si estás en la rama maestra y ejecutas el comando git pull, automáticamente combinará la rama maestra remota con tu rama local, luego de haber traído toda la información de ella. También lista todas las referencias remotas de las que ha traído datos. Ejemplos como este son los que te encontrarás normalmente. Sin embargo, si usas Git de forma más avanzada, puede que obtengas mucha más información de un git remote show.
Este comando te indica a cuál rama enviarás información automáticamente cada vez que ejecutas git push, dependiendo de la rama en la que estés. También te muestra cuáles ramas remotas no tienes aún, cuáles ramas remotas tienes que han sido eliminadas del servidor, y varias ramas que serán combinadas automáticamente cuando ejecutes git pull.
Eliminar y Renombrar Remotos
Si quieres cambiar el nombre de la referencia de un remoto puedes ejecutar git remote rename. 
Es importante destacar que al hacer esto también cambias el nombre de las ramas remotas. 
Si por alguna razón quieres eliminar un remoto - has cambiado de servidor o no quieres seguir utilizando un mirror o quizás un colaborador ha dejado de trabajar en el proyecto - puedes usar **git remote rm.**
### ¿Qué es una rama? ### 
Para entender realmente cómo ramifica Git, previamente hemos de examinar la forma en que almacena sus datos. Recordando lo citado, Git no los almacena de forma incremental (guardando sólo diferencias), sino que los almacena como una serie de instantáneas (copias puntuales de los archivos completos, tal y como se encuentran en ese momento). En cada confirmación de cambios (commit), Git almacena una instantánea de tu trabajo preparado. Dicha instantánea contiene además unos metadatos con el autor y el mensaje explicativo, y uno o varios apuntadores a las confirmaciones (commit) que sean padres directos de esta (un padre en los casos de confirmación normal, y múltiples padres en los casos de estar confirmando una fusión (merge) de dos o más ramas). Para ilustrar esto, vamos a suponer, por ejemplo, que tienes una carpeta con tres archivos, que preparas (stage) todos ellos y los confirmas (commit). Al preparar los archivos, Git realiza una suma de control de cada uno de ellos (un resumen SHA-1, tal y como se mencionaba en Inicio - Sobre el Control de Versiones), almacena una copia de cada uno en el repositorio (estas copias se denominan "blobs"), y guarda cada suma de control en el área de preparación (staging area).
Cuando creas una confirmación con el comando git commit, Git realiza sumas de control de cada subdirectorio (en el ejemplo, solamente tenemos el directorio principal del proyecto), y las guarda como objetos árbol en el repositorio Git. Después, Git crea un objeto de confirmación con los metadatos pertinentes y un apuntador al objeto árbol raíz del proyecto. En este momento, el repositorio de Git contendrá cinco objetos: un "blob" para cada uno de los tres archivos, un árbol con la lista de contenidos del directorio (más sus respectivas relaciones con los "blobs"), y una confirmación de cambios (commit) apuntando a la raíz de ese árbol y conteniendo el resto de metadatos pertinentes. Una rama Git es simplemente un apuntador móvil apuntando a una de esas confirmaciones. La rama por defecto de Git es la rama master. Con la primera confirmación de cambios que realicemos, se creará esta rama principal master apuntando a dicha confirmación. En cada confirmación de cambios que realicemos, la rama irá avanzando automáticamente.
### Cambiar de Rama ### 
Para saltar de una rama a otra, tienes que utilizar el comando **git checkout**. 
### Procedimientos Básicos de Fusión ### 
Supongamos que tu trabajo con el problema #53 ya está completo y listo para fusionarlo (merge) con la rama master. Para ello, de forma similar a como antes has hecho con la rama hotfix, vas a fusionar la rama iss53. Simplemente, activa (checkout) la rama donde deseas fusionar y lanza el comando git merge
Es algo diferente de la fusión realizada anteriormente con hotfix. En este caso, el registro de desarrollo había divergido en un punto anterior. Debido a que la confirmación en la rama actual no es ancestro directo de la rama que pretendes fusionar, Git tiene cierto trabajo extra que hacer. Git realizará una fusión a tres bandas, utilizando las dos instantáneas apuntadas por el extremo de cada una de las ramas y por el ancestro común a ambas. En lugar de simplemente avanzar el apuntador de la rama, Git crea una nueva instantánea (snapshot) resultante de la fusión a tres bandas; y crea automáticamente una nueva confirmación de cambios (commit) que apunta a ella. Nos referimos a este proceso como "fusión confirmada" y su particularidad es que tiene más de un padre. Vale la pena destacar el hecho de que es el propio Git quien determina automáticamente el mejor ancestro común para realizar la fusión; a diferencia de otros sistemas tales como CVS o Subversion, donde es el desarrollador quien ha de determinar cuál puede ser dicho mejor ancestro común. Esto hace que en Git sea mucho más fácil realizar fusiones..
### Principales Conflictos que Pueden Surgir en las Fusiones ### 
En algunas ocasiones, los procesos de fusión no suelen ser fluidos. Si hay modificaciones dispares en una misma porción de un mismo archivo en las dos ramas distintas que pretendes fusionar, Git no será capaz de fusionarlas directamente. Git no crea automáticamente una nueva fusión confirmada (merge commit), sino que hace una pausa en el proceso, esperando a que tú resuelvas el conflicto. Todo aquello que sea conflictivo y no se haya podido resolver, se marca como "sin fusionar" (unmerged). Git añade a los archivos conflictivos unos marcadores especiales de resolución de conflictos que te guiarán cuando abras manualmente los archivos implicados y los edites para corregirlos. Si todo ha ido correctamente, y ves que todos los archivos conflictivos están marcados como preparados, puedes lanzar el comando git commit para terminar de confirmar la fusión.
### Gestión de Ramas ### 
Ahora que ya has creado, fusionado y borrado algunas ramas, vamos a dar un vistazo a algunas herramientas de gestión muy útiles cuando comienzas a utilizar ramas de manera avanzada. El comando git branch tiene más funciones que las de crear y borrar ramas. Si lo lanzas sin parámetros, obtienes una lista de las ramas presentes en tu proyecto.
Otra opción útil para averiguar el estado de las ramas, es filtrarlas y mostrar solo aquellas que han sido fusionadas (o que no lo han sido) con la rama actualmente activa. Para ello, Git dispone de las opciones --merged y --no-merged. Si deseas ver las ramas que han sido fusionadas con la rama activa, puedes lanzar el comando git branch –merged.   



## Instructivo paso a paso de Git y Github ##
### Como clonar un repositorio ###
1)	En nuestro disco creamos una carpeta nueva, o bien abrimos una donde colocaremos nuestro proyecto.
2)	 Dentro de la carpeta hacer click derecho y seleccionar **GIT BASH HERE** (que abre la consola de git)
3)	Nos dirigimos a nuestro repositorio en GitHub en la pestaña de **“Code”** o **“Código”**, luego verificamos que estemos parados sobre la **“rama”** o **“branch”**, **“main”** o **“principal”**, y presionamos sobre el botón verde que dice **“Code”** o **“Código”**. Luego copiamos la dirección marcada que es por protocolo **HTTPS**.
4)	Dentro de la consola tipear git clone y pegar la direccion copiada en el punto anterior, y damos enter.
5)	 Veremos que dentro de la carpeta del punto 1, se nos creo otra carpeta con el nombre del proyecto.

### Como crear una rama ###
1)	Volvemos a la consola y tipeamos **cd + “nombre_del_proyecto”** para posicionarnos dentro del mismo (o desde el explorador, abrimos la carpeta "nombre_del_proyecto", damos click derecho y seleccionamos **GIT BASH HERE**.)
2)	Tipeamos el comando **git branch "nombre_de_la_rama"** (el nombre que quieran, en mi caso usé desarrolladorMaxi), y damos Enter. Veremos en la consola que seguimos en la rama main o master.
3)	Para entrar a nuestra rama: escribimos el comando **git checkout "nombre_de_la_rama"** y damos enter.
Luego de haber realizado estos pasos ya podemos empezar a trabajar sobre nuestro “espacio de trabajo” o “branch” o “rama” como más les guste llamarlo.

### Como subir codigo a Github mediante Git ###
1)	Abrir la consola de git en la carpeta en la cual se clonaron el proyecto, donde veremos que se encuentran las carpetas .git y .github.
2)	Dentro de la consola tipeamos el comando **git status** para poder ver los cambios que tenemos en nuestro espacio o rama de trabajo. Nos mostrará en rojo los archivos que hayamos modificado.
3)	Para agregar estos archivos al commit para luego subirlos debemos ingresar el comando **git add + “nombre_de_archivo”** (si solo queremos subir los cambios de un archivo especifico), o el comando **git add .** (si queremos subir todos los cambios realizados.)
4)	Una vez realizado el paso anterior, tipeamos el comando **git status** y veremos que el/los archivo/s subidos se encuentran en color verde.
5)	Luego debemos ingresar el comando **git commit –m “aquí agregamos un mensaje descriptivo de lo que estamos por subir al repositorio”** (para identificar los cambios a subir)
6)	Ahora vamos a ingresar el comando **git pull origin main**, para bajarnos o tener al día todos los cambios que estén en la rama principal del repositorio remoto (para no perder ningún cambio que hayan realizado los demás participantes del grupo en el repositorio)
7)	Luego de habernos bajado todos los cambios y de que se hayan “fusionado” o “mergeado” automáticamente se deben de subir nuestros cambios locales al repositorio remoto con el comando **git push** ó para más seguridad especificarle desde donde se quieren subir los cambios con el comando **git push origin + “nombre_de_la_rama”**.
Luego de realizados estos pasos nos dirigimos a GitHub para realizar la correcta fusión desde “nuestra rama” ó “espacio de trabajo” hacia la rama “principal” ó “main”.
1)	En GitHub nos encontraremos con un cartel que nos indica el nombre de nuestra rama (en la que estuvimos trabajando), avisándonos de que se subió código recientemente, brindándonos un botón de color verde que nos dice **“Compare & pull request”** ó “Comparar y solicitar extracción”.
2)	Al presionar este botón **“Compare & pull request”** ó “Comparar y solicitar extracción” nos muestra las opciones de la siguiente pantalla, donde nos deja proporcionarle un título y una descripción a la fusión de los cambios. Luego de realizadas estas acciones presionamos en el botón **“Create pull request”** ó “Crear solicitud de Extracción”.
3)	Luego redirecciona a la siguiente pantalla proporcionando la información de la fusión de los cambios y que la rama no cuenta con conflictos con la rama Base, y presionamos el botón **“Merge pull request”** o “Combinar solicitud de extracción”.
4)	Por último, presionamos el botón **“Confirm merge”** o “Confirmar fusión”. 

